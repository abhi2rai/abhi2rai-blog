{"version":3,"sources":["../../src/utils/map-templates-to-static-query-hashes.ts"],"names":["entryNodes","mapTemplatesToStaticQueryHashes","reduxState","compilation","components","staticQueryComponents","modules","globalStaticQueries","Set","getDeps","mod","staticQueryModuleComponentPath","resource","result","seen","getDepsRec","m","hasReasons","isEntryNode","some","entryNode","includes","nonTerminalDependents","reasons","filter","r","dependentModule","module","isTerminal","map","Boolean","has","uniqDependents","d","identifier","uniqDependent","add","isGatsbyBrowser","mapOfStaticQueryComponentsToDependants","Map","forEach","componentPath","staticQueryComponentModule","find","dependants","set","mapOfComponentsToStaticQueryHashes","mapComponentsToStaticQueryHashes","globalStaticQueryHashes","q","hash","get","push","mapOfTemplatesToStaticQueryHashes","page","staticQueryHashes","setOfDependants","staticQueryComponentPath","sort","String"],"mappings":"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","sourcesContent":["import { uniqBy, List } from \"lodash\"\nimport { IGatsbyState } from \"../redux/types\"\nimport { Stats } from \"webpack\"\n\ninterface ICompilation {\n  modules: IModule[]\n}\n\ninterface IReason extends Omit<Stats.Reason, \"module\"> {\n  module: IModule\n}\n\ninterface IModule extends Omit<Stats.FnModules, \"identifier\" | \"reasons\"> {\n  hasReasons: () => boolean\n  resource?: string\n  identifier: () => string\n  reasons: IReason[]\n}\n\n/* When we traverse upwards, we need to know where to stop. We'll call these terminal nodes.\n * `async-requires.js` is the entry point for every page, while `api-runner-browser-plugins.js`\n * is the one for `gatsby-browser` (where one would use wrapRootElement or wrapPageElement APIs)\n */\nconst entryNodes = [\n  `.cache/api-runner-browser-plugins.js`,\n  `.cache/async-requires.js`,\n]\n\n/* This function takes the current Redux state and a compilation\n * object from webpack and returns a map of unique templates\n * to static queries included in each (as hashes).\n *\n * This isn't super straightforward because templates may include\n * deep component trees with static queries present at any depth.\n * This is why it is necessary to map templates to all their (user land and node_modules)\n * dependencies first and then map those dependencies to known static queries.\n *\n * Also, Gatsby makes it possible to wrap an entire site or page with a layout\n * or other component(s) via the wrapRootElement and wrapPageElement APIs. These must\n * also be handled when computing static queries for a page.\n *\n * Let's go through the implementation step by step.\n */\nexport default function mapTemplatesToStaticQueryHashes(\n  reduxState: IGatsbyState,\n  compilation: ICompilation\n): Map<string, Array<number>> {\n  /* The `staticQueryComponents` slice of state is useful because\n   * it is a pre extracted collection of all static queries found in a Gatsby site.\n   * This lets us traverse upwards from those to templates that\n   * may contain components that contain them.\n   * Note that this upward traversal is much shallower (and hence more performant)\n   * than an equivalent downward one from an entry point.\n   */\n  const { components, staticQueryComponents } = reduxState\n  const { modules } = compilation\n\n  /* We call the queries included above a page (via wrapRootElement or wrapPageElement APIs)\n   * global queries. For now, we include these in every single page for simplicity. Overhead\n   * here is not much since we are storing hashes (that reference separate result files)\n   * as opposed to inlining results. We may move these to app-data perhaps in the future.\n   */\n  const globalStaticQueries = new Set<string>()\n\n  /* This function takes a webpack module corresponding\n   * to the file containing a static query and returns\n   * a Set of strings, each an absolute path of a dependent\n   * of this module\n   */\n  function getDeps(mod: IModule): Set<string> {\n    const staticQueryModuleComponentPath = mod.resource\n    const result = new Set<string>()\n    const seen = new Set<string>(\n      staticQueryModuleComponentPath ? [staticQueryModuleComponentPath] : []\n    )\n\n    // This is the body of the recursively called function\n    function getDepsRec(m: IModule, seen: Set<string>): Set<string> {\n      // Reasons in webpack are literally reasons of why this module was included in the tree\n      const hasReasons = m.hasReasons()\n\n      // Is this node one of our known terminal nodes? See explanation above\n      const isEntryNode = entryNodes.some(entryNode =>\n        m?.resource?.includes(entryNode)\n      )\n\n      // Exit if we don't have any reasons or we have reached a possible terminal node\n      if (!hasReasons || isEntryNode) {\n        return result\n      }\n\n      // These are non terminal dependents and hence modules that need\n      // further upward traversal\n      const nonTerminalDependents: List<IModule> = m.reasons\n        .filter(r => {\n          const dependentModule = r.module\n          const isTerminal = entryNodes.some(entryNode =>\n            dependentModule?.resource?.includes(entryNode)\n          )\n          return !isTerminal\n        })\n        .map(r => r.module)\n        .filter(Boolean)\n        .filter(r => !r.resource || !seen.has(r.resource))\n\n      const uniqDependents = uniqBy(nonTerminalDependents, d => d?.identifier())\n\n      for (const uniqDependent of uniqDependents) {\n        if (uniqDependent.resource) {\n          result.add(uniqDependent.resource)\n          // Queries used in gatsby-browser are global and should be added to all pages\n          if (isGatsbyBrowser(uniqDependent)) {\n            if (staticQueryModuleComponentPath) {\n              globalStaticQueries.add(staticQueryModuleComponentPath)\n            }\n          } else {\n            seen.add(uniqDependent.resource)\n          }\n        }\n\n        getDepsRec(uniqDependent, seen)\n      }\n\n      return result\n    }\n\n    return getDepsRec(mod, seen)\n  }\n\n  const mapOfStaticQueryComponentsToDependants = new Map()\n\n  // For every known static query, we get its dependents.\n  staticQueryComponents.forEach(({ componentPath }) => {\n    const staticQueryComponentModule = modules.find(\n      m => m.resource === componentPath\n    )\n\n    const dependants = staticQueryComponentModule\n      ? getDeps(staticQueryComponentModule)\n      : new Set()\n\n    mapOfStaticQueryComponentsToDependants.set(componentPath, dependants)\n  })\n\n  const mapOfComponentsToStaticQueryHashes = mapComponentsToStaticQueryHashes(\n    staticQueryComponents\n  )\n\n  const globalStaticQueryHashes: string[] = []\n\n  globalStaticQueries.forEach(q => {\n    const hash = mapOfComponentsToStaticQueryHashes.get(q)\n    if (hash) {\n      globalStaticQueryHashes.push(hash)\n    }\n  })\n\n  // For every known page, we get queries\n  const mapOfTemplatesToStaticQueryHashes = new Map()\n\n  components.forEach(page => {\n    const staticQueryHashes = [...globalStaticQueryHashes]\n\n    // Does this page contain an inline static query?\n    if (mapOfComponentsToStaticQueryHashes.has(page.componentPath)) {\n      const hash = mapOfComponentsToStaticQueryHashes.get(page.componentPath)\n      if (hash) {\n        staticQueryHashes.push(hash)\n      }\n    }\n\n    // Check dependencies\n    mapOfStaticQueryComponentsToDependants.forEach(\n      (setOfDependants, staticQueryComponentPath) => {\n        if (setOfDependants.has(page.componentPath)) {\n          const hash = mapOfComponentsToStaticQueryHashes.get(\n            staticQueryComponentPath\n          )\n          if (hash) {\n            staticQueryHashes.push(hash)\n          }\n        }\n      }\n    )\n\n    mapOfTemplatesToStaticQueryHashes.set(\n      page.componentPath,\n      staticQueryHashes.sort().map(String)\n    )\n  })\n\n  return mapOfTemplatesToStaticQueryHashes\n}\n\nfunction mapComponentsToStaticQueryHashes(\n  staticQueryComponents: IGatsbyState[\"staticQueryComponents\"]\n): Map<string, string> {\n  const map = new Map()\n\n  staticQueryComponents.forEach(({ componentPath, hash }) => {\n    map.set(componentPath, hash)\n  })\n\n  return map\n}\n\nfunction isGatsbyBrowser(m: IModule): boolean {\n  return !!m?.resource?.includes(`gatsby-browser.js`)\n}\n"],"file":"map-templates-to-static-query-hashes.js"}